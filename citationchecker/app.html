<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <div class="footer">
            <div style="padding: 25px; background: #f0f4ff; border-radius: 8px; border-left: 4px solid #667eea; margin-bottom: 20px;">
                <div style="font-size: 0.85em; color: #555; line-height: 1.8;">
                    <strong>Status:</strong> In active development | Feedback: <a href="mailto:junhoc94@gmail.com" style="color: #667eea; font-weight: 600;">junhoc94@gmail.com</a><br>
                    <strong>Disclaimer:</strong> For educational support only; verify important citations manually.<br>
                    <strong>Citation Verification Tool</strong> by Chai Jun Ho (2025) | <a href="https://opensource.org/license/mit" target="_blank" rel="noopener noreferrer" style="color: #667eea; font-weight: 600;">MIT License</a> 
                    [<a href="./MIT-License.md" target="_blank" rel="noopener noreferrer" style="color: #667eea;">üìÑ Full License</a>] <br>
                    <strong>Citation:</strong> Chai, J. H. (2025). <em>Citation verification tool (Version 1.0) [Web application]</em>. <a href="https://junhochai.github.io/citationchecker/app.html" target="_blank"> https://junhochai.github.io/citationchecker.html </a><br>
                    <strong>Data:</strong> Crossref & OpenAlex APIs (176M+ works) <br>
                </div>
            </div>
        </div>

    <title>Citation Verification Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .input-section {
            background: white;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .format-selector {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 25px;
            border-left: 4px solid #667eea;
        }

        .format-selector label {
            display: block;
            margin-bottom: 12px;
            font-weight: 600;
            color: #333;
            font-size: 1.05em;
        }

        .format-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .radio-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .radio-group input[type="radio"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
            accent-color: #667eea;
        }

        .radio-group label {
            margin: 0;
            cursor: pointer;
            font-weight: 500;
        }

        .format-hint {
            margin-top: 12px;
            font-size: 0.9em;
            color: #666;
            padding: 10px;
            background: white;
            border-radius: 4px;
            border-left: 2px solid #ff9800;
        }

        .input-section > label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
            margin-top: 20px;
        }

        .input-section > label:first-child {
            margin-top: 0;
        }

        textarea {
            width: 100%;
            height: 150px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .help-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 8px;
            padding: 10px;
            background: #f9f9f9;
            border-left: 3px solid #667eea;
            border-radius: 4px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .btn-success {
            background: #4caf50;
            color: white;
        }

        .btn-success:hover {
            background: #45a049;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .progress-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .progress-section.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
        }

        .progress-text {
            font-size: 0.9em;
            color: #666;
        }

        .results-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .results-section h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .table-wrapper {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95em;
        }

        th {
            background: #f5f5f5;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #e0e0e0;
            color: #333;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
        }

        tr:hover {
            background: #fafafa;
        }

        .status-verified {
            color: #4caf50;
            font-weight: 600;
        }

        .status-warning {
            color: #ff9800;
            font-weight: 600;
        }

        .status-error {
            color: #f44336;
            font-weight: 600;
        }

        .status-pending {
            color: #2196f3;
            font-weight: 600;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 500;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .badge-success {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .badge-warning {
            background: #fff3e0;
            color: #e65100;
        }

        .badge-error {
            background: #ffebee;
            color: #c62828;
        }

        .badge-info {
            background: #e3f2fd;
            color: #1565c0;
        }

        .badge-danger {
            background: #fce4ec;
            color: #c2185b;
        }

        .details-cell {
            max-width: 300px;
            word-wrap: break-word;
            font-size: 0.9em;
            color: #666;
        }

        .no-results {
            padding: 40px;
            text-align: center;
            color: #999;
        }

        .footer {
            margin-top: 40px;
            padding: 20px;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }

        .sample-citations {
            margin-top: 15px;
            padding: 15px;
            background: #f0f4ff;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .sample-citations strong {
            display: block;
            margin-bottom: 8px;
        }

        .sample-citations code {
            display: block;
            padding: 8px;
            background: white;
            border-radius: 4px;
            margin: 6px 0;
            font-size: 0.9em;
            overflow-x: auto;
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #f44336;
        }

        .success-message {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border-left: 4px solid #4caf50;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }

            .table-wrapper {
                font-size: 0.85em;
            }

            .button-group {
                flex-direction: column;
            }

            button {
                width: 100%;
            }

            .format-options {
                flex-direction: column;
                gap: 12px;
            }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state svg {
            width: 100px;
            height: 100px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .doi-column {
            font-weight: 600;
        }

        .doi-missing {
            color: #c2185b;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö Citation Verification Tool</h1>
            <p>Verify academic citations against Crossref and OpenAlex databases</p>
        </header>

        <div class="input-section">
            <!-- FORMAT SELECTOR -->
            <div class="format-selector">
                <label>üìã Citation Format (Required)</label>
                <div class="format-options">
                    <div class="radio-group">
                        <input type="radio" id="format-auto" name="citation-format" value="auto" checked>
                        <label for="format-auto">Auto-detect</label>
                    </div>
                    <div class="radio-group">
                        <input type="radio" id="format-apa" name="citation-format" value="apa">
                        <label for="format-apa">APA (7th ed.)</label>
                    </div>
                    <div class="radio-group">
                        <input type="radio" id="format-harvard" name="citation-format" value="harvard">
                        <label for="format-harvard">Harvard</label>
                    </div>
                    <div class="radio-group">
                        <input type="radio" id="format-mla" name="citation-format" value="mla">
                        <label for="format-mla">MLA</label>
                    </div>
                    <div class="radio-group">
                        <input type="radio" id="format-chicago" name="citation-format" value="chicago">
                        <label for="format-chicago">Chicago</label>
                    </div>
                </div>
                <div class="format-hint" id="formatHint">
                    üí° Different formats use different structures. Selecting the correct format improves parsing accuracy.
                </div>
            </div>

            <!-- CITATIONS INPUT -->
            <label for="citations">Paste your citations (one per line):</label>
            <textarea id="citations" placeholder="Chai, J. H., & Ko, E. S. (2025). Input Properties Shape Word Segmentation Performance Across Child Development: A Computational Modeling Study. Infancy, 30(5), e70046. https://doi.org/10.1111/infa.70046&#10;Chai, J. H., Low, H. M., Wong, T. P., Onnis, L., & Mayor, J. (2021). Extra-linguistic modulation of the English noun-bias: Evidence from Malaysian bilingual infants and toddlers. Journal of Cultural Cognitive Science, 5(1), 49-64. https://doi.org/10.1007/s41809-021-00078-5"></textarea>
            <div class="help-text">
                ‚ÑπÔ∏è <strong>Tips for best results:</strong>
                <br>‚úì Include DOI if available (will be used for verification if present)
                <br>‚úì Each citation on a separate line
                <br>‚úì Ensure format matches your selected citation style
                <br>‚ö†Ô∏è If no DOI, title + year will be used as fallback
            </div>

            <div class="sample-citations">
                <strong>Example citations by format (with & without DOI):</strong>
                <code><strong>APA with DOI:</strong> Chai, J. H., & Ko, E. S. (2025). Input Properties Shape Word Segmentation Performance Across Child Development: A Computational Modeling Study. Infancy, 30(5), e70046. https://doi.org/10.1111/infa.70046</code>
                <code><strong>APA without DOI:</strong> Abu-Zhaya, R., Seidl, A. and Cristia, A., 2017. Multimodal infant-directed communication. Journal of Child Language, 44(5), pp.1088‚Äì1116. </code>
                <code><strong>Harvard with DOI:</strong> Chai, J. H., Low, H. M., Wong, T. P., Onnis, L., & Mayor, J., 2021. Extra-linguistic modulation of the English noun-bias: Evidence from Malaysian bilingual infants and toddlers. Journal of Cultural Cognitive Science, 5(1), pp.49-64. Available at https://doi.org/10.1007/s41809-021-00078-5</code>
                <code><strong>Harvard without DOI:</strong> Brown, K. and Davis, J., 2020. Emotion recognition in infants. Early Development Review, 25(3), pp.245-267.</code>
            </div>

            <div class="button-group">
                <button class="btn-primary" onclick="verifyCitations()">üîç Verify Citations</button>
                <button class="btn-secondary" onclick="loadExample()">üìã Load Example</button>
                <button class="btn-secondary" onclick="clearInput()">üóëÔ∏è Clear</button>
            </div>
        </div>

        <div class="progress-section" id="progressSection">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div class="progress-text">
                Processing: <span id="progressCount">0</span> / <span id="totalCount">0</span>
            </div>
        </div>

        <div class="results-section" id="resultsSection" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div>
                    <h2>Verification Results</h2>
                    <div style="font-size: 0.9em; color: #666;">Format used: <strong id="usedFormat">APA</strong></div>
                </div>
                <div class="button-group" style="margin: 0;">
                    <button class="btn-success" onclick="exportToCSV()">üì• Export to CSV</button>
                    <button class="btn-secondary" onclick="printResults()">üñ®Ô∏è Print</button>
                </div>
            </div>
            <div class="table-wrapper">
                <table id="resultsTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Your Citation</th>
                            <th>Lookup Method</th>
                            <th>Status</th>
                            <th>Title Match</th>
                            <th>Authors</th>
                            <th>Year</th>
                            <th>Journal/Source</th>
                            <th>Issues</th>
                        </tr>
                    </thead>
                    <tbody id="resultsBody">
                    </tbody>
                </table>
            </div>
            <div style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 6px;">
                <strong>Summary:</strong>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 10px;">
                    <div><span class="status-verified">‚úì Verified:</span> <span id="countVerified">0</span></div>
                    <div><span class="status-warning">‚ö† Warning:</span> <span id="countWarning">0</span></div>
                    <div><span class="status-error">‚úó Not Found:</span> <span id="countNotFound">0</span></div>
                    <div style="color: #c2185b; font-weight: 600;">üö© Missing DOI: <span id="countNoDOI">0</span></div>
                </div>
            </div>
        </div>

        <div class="empty-state" id="emptyState">
            <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                <rect x="20" y="30" width="160" height="140" fill="none" stroke="currentColor" stroke-width="2" rx="4"/>
                <line x1="20" y1="50" x2="180" y2="50" stroke="currentColor" stroke-width="2"/>
                <line x1="30" y1="65" x2="170" y2="65" stroke="currentColor" stroke-width="1"/>
                <line x1="30" y1="80" x2="170" y2="80" stroke="currentColor" stroke-width="1"/>
                <line x1="30" y1="95" x2="150" y2="95" stroke="currentColor" stroke-width="1"/>
                <line x1="30" y1="110" x2="170" y2="110" stroke="currentColor" stroke-width="1"/>
                <line x1="30" y1="125" x2="160" y2="125" stroke="currentColor" stroke-width="1"/>
            </svg>
            <h3>No citations loaded yet</h3>
            <p>Select a format, paste citations, and click "Verify Citations" to get started</p>
        </div>
    </div>

    <script>
        // ============================================================================
        // FORMAT-SPECIFIC PARSING RULES
        // ============================================================================

        const FORMAT_PARSERS = {
            'apa': {
                name: 'APA (7th Edition)',
                description: 'LastName, F. (Year). Title. Journal. https://doi.org/xxx',
                parser: function(text) {
                    const citation = {
                        original: text.trim(),
                        title: null,
                        authors: [],
                        year: null,
                        doi: null,
                        journal: null,
                        hasDOI: false,
                    };

                    // Extract DOI FIRST (user-supplied, priority) - handles [url], url, and doi: formats
                    let doiMatch = text.match(/[\[\s]*(https?:\/\/doi\.org\/|doi:\s*)(10\.\d+\/\S+?)(?:[\]\s]|$)/i);
                    if (doiMatch && doiMatch[2]) {
                        citation.doi = doiMatch[2].trim();
                        citation.hasDOI = true;
                    }

                    // Extract year: (YYYY)
                    const yearMatch = text.match(/\((\d{4})\)/);
                    if (yearMatch) citation.year = yearMatch[1];

                    // Extract title: usually after year, before period and journal
                    const titleMatch = text.match(/\d{4}\)\.\s+([^.]+)\./);
                    if (titleMatch) {
                        citation.title = titleMatch[1].trim();
                    }

                    // Extract authors: before year
                    const authorMatch = text.match(/^([^(]+?)\s*\(\d{4}\)/);
                    if (authorMatch) {
                        const authorText = authorMatch[1].trim();
                        citation.authors = authorText.split(/&|,\s*and\s+/i)
                            .map(a => a.trim())
                            .filter(a => a && a.length > 0);
                    }

                    // Extract journal: after title, before volume
                    const journalMatch = text.match(/\.\s+([^,]+),\s+\d+/);
                    if (journalMatch) {
                        citation.journal = journalMatch[1].trim();
                    }

                    return citation;
                }
            },

            'harvard': {
                name: 'Harvard',
                description: 'LastName, F. and LastName, F., Year. Title. Journal.',
                parser: function(text) {
                    const citation = {
                        original: text.trim(),
                        title: null,
                        authors: [],
                        year: null,
                        doi: null,
                        journal: null,
                        hasDOI: false,
                    };

                    // Extract DOI FIRST - handles [url], url, and doi: formats
                    let doiMatch = text.match(/[\[\s]*(https?:\/\/doi\.org\/|doi:\s*)(10\.\d+\/\S+?)(?:[\]\s]|$)/i);
                    if (doiMatch && doiMatch[2]) {
                        citation.doi = doiMatch[2].trim();
                        citation.hasDOI = true;
                    }

                    // Extract year: YYYY with comma/period around it
                    const yearMatch = text.match(/,\s*(\d{4})[.,]/);
                    if (yearMatch) citation.year = yearMatch[1];

                    // Extract title: after year, typically between periods
                    const titleMatch = text.match(/\d{4}\.\s+([^.]+)\./);
                    if (titleMatch) {
                        citation.title = titleMatch[1].trim();
                    }

                    // Extract authors: before year (Harvard uses "and" not "&")
                    const authorMatch = text.match(/^([^,]+(?:\s+and\s+[^,]+)*?),\s*\d{4}/i);
                    if (authorMatch) {
                        const authorText = authorMatch[1].trim();
                        citation.authors = authorText.split(/\s+and\s+/i)
                            .map(a => a.trim())
                            .filter(a => a && a.length > 0);
                    }

                    // Extract journal
                    const journalMatch = text.match(/,\s+pp\.\s+\d+[‚Äì-]\d+\.\s+([^.,]+)/);
                    if (!journalMatch) {
                        const altMatch = text.match(/\.\s+([^,.]+),\s+\d+\s*\(/);
                        if (altMatch) citation.journal = altMatch[1].trim();
                    } else {
                        citation.journal = journalMatch[1].trim();
                    }

                    return citation;
                }
            },

            'mla': {
                name: 'MLA (9th Edition)',
                description: 'LastName, FirstName. "Title." Journal, vol. X, 2020, pp. XX-XX.',
                parser: function(text) {
                    const citation = {
                        original: text.trim(),
                        title: null,
                        authors: [],
                        year: null,
                        doi: null,
                        journal: null,
                        hasDOI: false,
                    };

                    // Extract DOI FIRST - handles [url], url, and doi: formats
                    let doiMatch = text.match(/[\[\s]*(https?:\/\/doi\.org\/|doi:\s*)(10\.\d+\/\S+?)(?:[\]\s]|$)/i);
                    if (doiMatch && doiMatch[2]) {
                        citation.doi = doiMatch[2].trim();
                        citation.hasDOI = true;
                    }

                    // Extract year: typically after "vol." in MLA, format: 2020
                    const yearMatch = text.match(/,\s*(\d{4}),/);
                    if (yearMatch) citation.year = yearMatch[1];

                    // Extract title: between quotes
                    const titleMatch = text.match(/"([^"]+)"/);
                    if (titleMatch) citation.title = titleMatch[1].trim();

                    // Extract authors: before first period, MLA uses "LastName, FirstName"
                    const authorMatch = text.match(/^([^.]+?)\./);
                    if (authorMatch) {
                        const authorText = authorMatch[1].trim();
                        citation.authors = authorText.split(/\s+and\s+|,\s+/i)
                            .map(a => a.trim())
                            .filter(a => a && a.length > 0);
                    }

                    // Extract journal
                    const journalMatch = text.match(/"[^"]+",\s+([^,]+),\s+vol/);
                    if (journalMatch) {
                        citation.journal = journalMatch[1].trim();
                    }

                    return citation;
                }
            },

            'chicago': {
                name: 'Chicago (Notes-Bibliography)',
                description: 'LastName, FirstName. "Title." Journal Vol (Year): pp.',
                parser: function(text) {
                    const citation = {
                        original: text.trim(),
                        title: null,
                        authors: [],
                        year: null,
                        doi: null,
                        journal: null,
                        hasDOI: false,
                    };

                    // Extract DOI FIRST - handles [url], url, and doi: formats
                    let doiMatch = text.match(/[\[\s]*(https?:\/\/doi\.org\/|doi:\s*)(10\.\d+\/\S+?)(?:[\]\s]|$)/i);
                    if (doiMatch && doiMatch[2]) {
                        citation.doi = doiMatch[2].trim();
                        citation.hasDOI = true;
                    }

                    // Extract year: in parentheses, format (YYYY)
                    const yearMatch = text.match(/\((\d{4})\)/);
                    if (yearMatch) citation.year = yearMatch[1];

                    // Extract title: between quotes
                    const titleMatch = text.match(/"([^"]+)"/);
                    if (titleMatch) citation.title = titleMatch[1].trim();

                    // Extract authors: before first quote, Chicago uses "FirstName LastName"
                    const authorMatch = text.match(/^([^"]+?)\./);
                    if (authorMatch) {
                        const authorText = authorMatch[1].trim();
                        citation.authors = authorText.split(/\s+and\s+|,\s+/i)
                            .map(a => a.trim())
                            .filter(a => a && a.length > 0);
                    }

                    // Extract journal
                    const journalMatch = text.match(/"[^"]+"\s+([^,\d]+?),\s+\d+/);
                    if (journalMatch) {
                        citation.journal = journalMatch[1].trim();
                    }

                    return citation;
                }
            },

            'auto': {
                name: 'Auto-detect',
                description: 'Tool will attempt to detect format automatically',
                parser: function(text) {
                    let detected = FORMAT_PARSERS.apa.parser(text);
                    
                    if (detected.authors.length === 0) {
                        detected = FORMAT_PARSERS.harvard.parser(text);
                    }
                    
                    if (detected.authors.length === 0) {
                        detected = FORMAT_PARSERS.mla.parser(text);
                    }

                    return detected;
                }
            }
        };

        document.querySelectorAll('input[name="citation-format"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const format = FORMAT_PARSERS[e.target.value];
                document.getElementById('formatHint').innerHTML = 
                    `üí° <strong>${format.name}:</strong> ${format.description}`;
            });
        });

        // ============================================================================
        // CITATION VERIFICATION ENGINE (IMPROVED WITH DOI PRIORITY)
        // ============================================================================

        class CitationVerifier {
            constructor(formatType = 'auto') {
                this.results = [];
                this.crossrefBaseUrl = 'https://api.crossref.org/works';
                this.openalexBaseUrl = 'https://api.openalex.org/works';
                this.userEmail = 'citation-verifier@research';
                this.requestDelay = 150;
                this.formatType = formatType;
                this.formatParser = FORMAT_PARSERS[formatType] || FORMAT_PARSERS.auto;
            }

            parseCitation(text) {
                return this.formatParser.parser(text);
            }

            calculateSimilarity(str1, str2) {
                if (!str1 || !str2) return 0;
                str1 = str1.toLowerCase().trim();
                str2 = str2.toLowerCase().trim();

                if (str1 === str2) return 100;

                // Handle colon-separated subtitles (e.g., "Main Title: Subtitle")
                // If main parts match, it's effectively a match
                const str1Main = str1.split(':')[0].trim();
                const str2Main = str2.split(':')[0].trim();
                if (str1Main === str2Main) {
                    return 95; // Main title matches, slight difference in subtitle
                }

                // Remove punctuation and normalize for word comparison
                const str1Clean = str1.replace(/[^\w\s]/g, ' ');
                const str2Clean = str2.replace(/[^\w\s]/g, ' ');
                
                // Split into words and remove common stopwords
                const stopwords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'as']);
                const words1 = new Set(str1Clean.split(/\s+/).filter(w => w && !stopwords.has(w)));
                const words2 = new Set(str2Clean.split(/\s+/).filter(w => w && !stopwords.has(w)));
                
                if (words1.size === 0 || words2.size === 0) return 0;
                
                const common = [...words1].filter(w => words2.has(w)).length;
                const total = Math.max(words1.size, words2.size);

                return Math.round((common / total) * 100);
            }

            // ‚úÖ FIX: If DOI provided, ONLY use DOI. Don't fall back.
            async fetchCrossref(citation) {
                try {
                    // PRIORITY 1: User-supplied DOI - USE ONLY THIS IF PROVIDED
                    if (citation.hasDOI && citation.doi) {
                        let params = new URLSearchParams();
                        params.append('filter', `doi:${citation.doi}`);
                        params.append('mailto', this.userEmail);
                        params.append('rows', '1');

                        const response = await fetch(`${this.crossrefBaseUrl}?${params}`);
                        const data = await response.json();

                        if (data.message && data.message.items && data.message.items.length > 0) {
                            return { data: data.message.items[0], method: 'DOI lookup' };
                        }
                        // If DOI provided but not found, return null (don't fallback)
                        return null;
                    }

                    // PRIORITY 2: No DOI provided - use title + year
                    if (citation.title && citation.year) {
                        let params = new URLSearchParams();
                        params.append('query.title', citation.title);
                        params.append('filter', `from-pub-date:${citation.year}-01-01,until-pub-date:${citation.year}-12-31`);
                        params.append('mailto', this.userEmail);
                        params.append('rows', '1');

                        const response = await fetch(`${this.crossrefBaseUrl}?${params}`);
                        const data = await response.json();

                        if (data.message && data.message.items && data.message.items.length > 0) {
                            return { data: data.message.items[0], method: 'Title + Year' };
                        }
                    }

                    // PRIORITY 3: Title + First Author
                    if (citation.title && citation.authors.length > 0) {
                        let params = new URLSearchParams();
                        params.append('query.title', citation.title);
                        params.append('query.author', citation.authors[0].split(',')[0]);
                        params.append('mailto', this.userEmail);
                        params.append('rows', '1');

                        const response = await fetch(`${this.crossrefBaseUrl}?${params}`);
                        const data = await response.json();

                        if (data.message && data.message.items && data.message.items.length > 0) {
                            return { data: data.message.items[0], method: 'Title + Author' };
                        }
                    }

                    // PRIORITY 4: Title only
                    if (citation.title) {
                        let params = new URLSearchParams();
                        params.append('query.title', citation.title);
                        params.append('mailto', this.userEmail);
                        params.append('rows', '1');

                        const response = await fetch(`${this.crossrefBaseUrl}?${params}`);
                        const data = await response.json();

                        if (data.message && data.message.items && data.message.items.length > 0) {
                            return { data: data.message.items[0], method: 'Title only' };
                        }
                    }

                } catch (error) {
                    console.error('Crossref error:', error);
                }
                return null;
            }

            async fetchOpenAlex(citation) {
                try {
                    let params = new URLSearchParams();

                    if (citation.hasDOI && citation.doi) {
                        params.append('filter', `doi:${citation.doi}`);
                        params.append('per-page', '1');

                        const response = await fetch(`${this.openalexBaseUrl}?${params}`);
                        const data = await response.json();

                        if (data.results && data.results.length > 0) {
                            return { data: data.results[0], method: 'DOI lookup' };
                        }
                        return null;
                    }

                    if (citation.title) {
                        params.append('search', citation.title);
                    } else if (citation.authors.length > 0) {
                        params.append('search', citation.authors[0]);
                    } else {
                        return null;
                    }

                    params.append('per-page', '1');

                    const response = await fetch(`${this.openalexBaseUrl}?${params}`);
                    const data = await response.json();

                    if (data.results && data.results.length > 0) {
                        const method = citation.title ? 'Title search' : 'Author search';
                        return { data: data.results[0], method: method };
                    }
                } catch (error) {
                    console.error('OpenAlex error:', error);
                }
                return null;
            }

            compareResults(citation, resultObj, source) {
                const dbData = resultObj.data;
                const lookupMethod = resultObj.method;

                const result = {
                    original: citation.original,
                    status: 'verified',
                    source: source,
                    lookupMethod: lookupMethod,
                    dbTitle: null,
                    dbAuthors: [],
                    dbYear: null,
                    dbJournal: null,
                    dbDoi: null,
                    titleMatch: 100,
                    issues: [],
                    confidence: 100,
                    hasDOI: citation.hasDOI,
                };

                if (!dbData) {
                    result.status = 'not_found';
                    result.confidence = 0;
                    return result;
                }

                if (source === 'crossref') {
                    result.dbTitle = dbData.title?.[0];
                    result.dbAuthors = (dbData.author || []).map(a => `${a.given} ${a.family}`).slice(0, 3);
                    result.dbYear = dbData.issued?.['date-parts']?.[0]?.[0];
                    result.dbJournal = dbData['container-title']?.[0];
                    result.dbDoi = dbData.DOI;
                } else if (source === 'openalex') {
                    result.dbTitle = dbData.title;
                    result.dbAuthors = (dbData.authorships || []).slice(0, 3).map(a => a.author?.display_name).filter(Boolean);
                    result.dbYear = dbData.publication_year;
                    result.dbJournal = dbData['host_venue']?.display_name;
                    result.dbDoi = dbData.doi;
                }

                if (result.dbTitle && citation.title) {
                    result.titleMatch = this.calculateSimilarity(citation.title, result.dbTitle);
                    if (result.titleMatch < 70) {
                        result.issues.push(`Title mismatch (${result.titleMatch}% similar)`);
                        result.status = 'warning';
                    }
                }

                if (result.dbYear && citation.year && result.dbYear.toString() !== citation.year) {
                    result.issues.push(`Year mismatch (cited: ${citation.year}, actual: ${result.dbYear})`);
                    result.status = 'warning';
                }

                if (result.dbAuthors.length > 0 && citation.authors.length > 0) {
                    const firstAuthorMatch = result.dbAuthors.some(dbAuth =>
                        citation.authors.some(citAuth =>
                            dbAuth.toLowerCase().includes(citAuth.toLowerCase().split(',')[0]) ||
                            citAuth.toLowerCase().includes(dbAuth.toLowerCase().split(' ')[0])
                        )
                    );
                    if (!firstAuthorMatch) {
                        result.issues.push('First author mismatch');
                        result.status = 'warning';
                    }
                }

                // Flag if no DOI provided
                if (!citation.hasDOI) {
                    result.issues.push('‚ö†Ô∏è No DOI provided (used fallback search)');
                }

                const scoreFactors = [
                    result.titleMatch,
                    !result.issues.some(i => i.includes('Year mismatch')) ? 100 : 50,
                    !result.issues.some(i => i.includes('author')) ? 100 : 75,
                ];
                result.confidence = Math.round(scoreFactors.reduce((a, b) => a + b) / scoreFactors.length);

                return result;
            }

            async verifyCitation(citation, index, total, progressCallback) {
                if (index > 0) {
                    await new Promise(resolve => setTimeout(resolve, this.requestDelay));
                }

                let result = null;

                const crossrefData = await this.fetchCrossref(citation);
                if (crossrefData) {
                    result = this.compareResults(citation, crossrefData, 'crossref');
                } else {
                    const openalexData = await this.fetchOpenAlex(citation);
                    if (openalexData) {
                        result = this.compareResults(citation, openalexData, 'openalex');
                    } else {
                        result = {
                            original: citation.original,
                            status: 'not_found',
                            source: 'none',
                            lookupMethod: citation.hasDOI ? 'DOI lookup (failed)' : 'Title/Author (not found)',
                            dbTitle: null,
                            dbAuthors: [],
                            dbYear: null,
                            dbJournal: null,
                            dbDoi: null,
                            titleMatch: 0,
                            issues: citation.hasDOI 
                                ? ['DOI lookup failed - citation may not exist or DOI may be incorrect']
                                : ['Citation not found in any database'],
                            confidence: 0,
                            hasDOI: citation.hasDOI,
                        };
                    }
                }

                result.index = index + 1;
                this.results.push(result);

                if (progressCallback) {
                    progressCallback(index + 1, total);
                }

                return result;
            }

            async verifyMultiple(citations, progressCallback) {
                this.results = [];
                const parsedCitations = citations.map(c => this.parseCitation(c));

                for (let i = 0; i < parsedCitations.length; i++) {
                    await this.verifyCitation(parsedCitations[i], i, parsedCitations.length, progressCallback);
                }

                return this.results;
            }
        }

        // ============================================================================
        // UI FUNCTIONS
        // ============================================================================

        let verifier = null;
        let allResults = [];

        async function verifyCitations() {
            const input = document.getElementById('citations').value.trim();
            if (!input) {
                alert('Please paste at least one citation');
                return;
            }

            const selectedFormat = document.querySelector('input[name="citation-format"]:checked').value;
            document.getElementById('usedFormat').textContent = FORMAT_PARSERS[selectedFormat].name;

            const citations = input.split('\n').filter(c => c.trim());

            verifier = new CitationVerifier(selectedFormat);

            const progressSection = document.getElementById('progressSection');
            progressSection.classList.add('active');
            document.getElementById('totalCount').textContent = citations.length;

            event.target.disabled = true;

            try {
                const results = await verifier.verifyMultiple(citations, (current, total) => {
                    document.getElementById('progressCount').textContent = current;
                    document.getElementById('progressFill').style.width = (current / total) * 100 + '%';
                });

                allResults = results;
                displayResults(results);
            } catch (error) {
                console.error('Verification error:', error);
                alert('An error occurred during verification: ' + error.message);
            } finally {
                event.target.disabled = false;
                progressSection.classList.remove('active');
                document.getElementById('emptyState').style.display = 'none';
            }
        }

        function displayResults(results) {
            const tbody = document.getElementById('resultsBody');
            const resultsSection = document.getElementById('resultsSection');

            tbody.innerHTML = '';

            let counts = { verified: 0, warning: 0, notFound: 0, noDOI: 0 };

            results.forEach((result, index) => {
                const row = document.createElement('tr');

                const statusClass =
                    result.status === 'verified' ? 'status-verified' :
                    result.status === 'warning' ? 'status-warning' :
                    result.status === 'not_found' ? 'status-error' : 'status-pending';

                const statusText =
                    result.status === 'verified' ? '‚úì Verified' :
                    result.status === 'warning' ? '‚ö† Warning' :
                    result.status === 'not_found' ? '‚úó Not Found' : '‚ü≥ Pending';

                counts[
                    result.status === 'verified' ? 'verified' :
                    result.status === 'warning' ? 'warning' :
                    result.status === 'not_found' ? 'notFound' : 'pending'
                ]++;

                if (!result.hasDOI) {
                    counts.noDOI++;
                }

                row.innerHTML = `
                    <td>${result.index}</td>
                    <td class="details-cell"><strong>${result.original.substring(0, 50)}...</strong></td>
                    <td class="details-cell"><strong>${result.lookupMethod}</strong></td>
                    <td class="${statusClass}">${statusText} (${result.confidence}%)</td>
                    <td>
                        ${result.dbTitle ? `<div class="badge badge-${result.status === 'verified' ? 'success' : result.status === 'warning' ? 'warning' : 'error'}">${result.titleMatch}%</div><div class="details-cell">${result.dbTitle}</div>` : 'N/A'}
                    </td>
                    <td class="details-cell">${result.dbAuthors.join(', ') || 'N/A'}</td>
                    <td>${result.dbYear || 'N/A'}</td>
                    <td class="details-cell">${result.dbJournal || 'N/A'}</td>
                    <td class="details-cell">${result.issues.map(issue => `<div class="badge badge-${issue.includes('‚ö†Ô∏è') ? 'danger' : result.status === 'verified' ? 'success' : result.status === 'warning' ? 'warning' : 'error'}">${issue}</div>`).join('')}</td>
                `;

                tbody.appendChild(row);
            });

            document.getElementById('countVerified').textContent = counts.verified;
            document.getElementById('countWarning').textContent = counts.warning;
            document.getElementById('countNotFound').textContent = counts.notFound;
            document.getElementById('countNoDOI').textContent = counts.noDOI;

            resultsSection.style.display = 'block';
        }

        function exportToCSV() {
            if (allResults.length === 0) {
                alert('No results to export');
                return;
            }

            const headers = ['Index', 'Original Citation', 'Lookup Method', 'Status', 'Confidence', 'Database Title', 'Database Authors', 'Database Year', 'Database Journal', 'Has DOI', 'Issues'];
            const rows = allResults.map(r => [
                r.index,
                r.original,
                r.lookupMethod,
                r.status.toUpperCase(),
                r.confidence + '%',
                r.dbTitle || '',
                (r.dbAuthors || []).join('; '),
                r.dbYear || '',
                r.dbJournal || '',
                r.hasDOI ? 'Yes' : 'No',
                (r.issues || []).join('; '),
            ]);

            let csv = [headers, ...rows].map(row =>
                row.map(cell => `"${cell.toString().replace(/"/g, '""')}"`).join(',')
            ).join('\n');

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `citation-verification-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function printResults() {
            window.print();
        }

        function loadExample() {
    const selectedFormat = document.querySelector('input[name="citation-format"]:checked').value;
    
    const examples = {
        'apa': `Chai, J. H., & Ko, E. S. (2025). Input Properties Shape Word Segmentation Performance Across Child Development: A Computational Modeling Study. Infancy, 30(5), e70046. https://doi.org/10.1111/infa.70046
Chai, J. H., Low, H. M., Wong, T. P., Onnis, L., & Mayor, J. (2021). Extra-linguistic modulation of the English noun-bias: Evidence from Malaysian bilingual infants and toddlers. Journal of Cultural Cognitive Science, 5(1), 49-64. https://doi.org/10.1007/s41809-021-00078-5
Brown, R., & Davis, K. (2018). Parental responsiveness and child outcomes. Early Childhood Research Quarterly, 42, 156-169.`,
        'harvard': `Abu-Zhaya, R., Seidl, A. and Cristia, A., 2017. Multimodal infant-directed communication. Journal of Child Language, 44(5), pp.1088‚Äì1116. doi: 10.1017/S0305000916000416
Chen, L., Lee, M. and Park, S., 2019. Language acquisition in multilingual children. Developmental Psychology, 55(2), pp.234-256.
Brown, R. and Davis, K., 2018. Parental responsiveness and child outcomes. Early Childhood Research Quarterly, 42, pp.156-169.`,
        'mla': `Abu-Zhaya, Ronit, et al. "Multimodal Infant-Directed Communication." Journal of Child Language, vol. 44, no. 5, 2017, pp. 1088‚Äì1116.
Chen, Ling, et al. "Language Acquisition in Multilingual Children." Developmental Psychology, vol. 55, no. 2, 2019, pp. 234-256.
Brown, Robert, and Kathryn Davis. "Parental Responsiveness and Child Outcomes." Early Childhood Research Quarterly, vol. 42, 2018, pp. 156-169.`,
        'chicago': `Chai, Jun Ho, and Eon-Suk Ko. "Input Properties Shape Word Segmentation Performance Across Child Development: A Computational Modeling Study." Infancy 30, no. 5 (2025): e70046. https://doi.org/10.1111/infa.70046
Chai, Jun Ho, Hui Min Low, Theng Ping Wong, Lukas Onnis, and Julien Mayor. "Extra-linguistic Modulation of the English Noun-Bias: Evidence from Malaysian Bilingual Infants and Toddlers." Journal of Cultural Cognitive Science 5, no. 1 (2021): 49‚Äì64. https://doi.org/10.1007/s41809-021-00078-5
Brown, Robert, and Kathryn Davis. "Parental Responsiveness and Child Outcomes." Early Childhood Research Quarterly 42 (2018): 156-169.`,
        'auto': `Chai, J. H., & Ko, E. S. (2025). Input Properties Shape Word Segmentation Performance Across Child Development: A Computational Modeling Study. Infancy, 30(5), e70046. https://doi.org/10.1111/infa.70046
Chai, J. H., Low, H. M., Wong, T. P., Onnis, L., & Mayor, J. (2021). Extra-linguistic modulation of the English noun-bias: Evidence from Malaysian bilingual infants and toddlers. Journal of Cultural Cognitive Science, 5(1), 49-64. https://doi.org/10.1007/s41809-021-00078-5
Brown, R., & Davis, K. (2018). Parental responsiveness and child outcomes. Early Childhood Research Quarterly, 42, 156-169.`
    };

    document.getElementById('citations').value = examples[selectedFormat] || examples['auto'];
}

        function clearInput() {
            document.getElementById('citations').value = '';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('emptyState').style.display = 'block';
            allResults = [];
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('emptyState').style.display = 'block';
        });
    </script>
</body>
</html>